
读写锁比排它锁允许更高的并发去访问共享数据。

ReentrantReadWriteLock:
	定义读锁（ReentrantReadWriteLock.ReadLock）和写锁（ReentrantReadWriteLock.WriteLock）

	写锁是一个支持重进入的排它锁，而读锁是一个共享锁



非公平下WriteLock源码分析：非公平下创建的sync=new NonfairSync()

   //获取写锁
   public void lock()
   {
         sync.acquire(1);
   }

//该方法有Sync实现
 protected final boolean tryAcquire(int acquires) 
 {
    //获取当前线程
    Thread current = Thread.currentThread();
    //获取同步状态值
    int c = getState();
    //获取写线程（排它锁）的数量，即写锁重入数
    int w = exclusiveCount(c);
    //写锁已经被占用，即重入锁
    if (c != 0) {
	//存在读锁或当前获取线程不是已经获取写锁的线程
	if (w == 0 || current != getExclusiveOwnerThread())
	    return false;
	//如果排他锁的数量大于MAX_COUNT(65535)，则抛出异常
	if (w + exclusiveCount(acquires) > MAX_COUNT)
	    throw new Error("Maximum lock count exceeded");
	// 更新同步状态值
	setState(c + acquires);
	return true;
    }
    //这里写锁还没有被占用，由WriteLock实现的writerShouldBlock返回值false
    if (writerShouldBlock() ||!compareAndSetState(c, c + acquires))
	return false;
    setExclusiveOwnerThread(current);
    return true;
 }
该方法除了重入锁之外，增加了一个读锁是否存在的判断，如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取
的情况下对写锁的获取，那么正在运行的其他线程就无法感知到当前写线程的操作，因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取
，则其他读写线程访问均被堵塞。


 //获取排他锁的数量
 static int exclusiveCount(int c)
 { 
    return c & EXCLUSIVE_MASK; 
 }
 运算原理：当前同步状态值c & 65535（0x0000FFFF）










 ReadLock源码分析：

public void lock()
{
   sync.acquireShared(1);
}

public final void acquireShared(int arg)
{
     if (tryAcquireShared(arg) < 0)
       doAcquireShared(arg);
}

protected final int tryAcquireShared(int unused)
{
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &&
	getExclusiveOwnerThread() != current)
	return -1;
    int r = sharedCount(c);
    if (!readerShouldBlock() &&
	r < MAX_COUNT &&
	compareAndSetState(c, c + SHARED_UNIT)) {
	if (r == 0) {
	    firstReader = current;
	    firstReaderHoldCount = 1;
	} else if (firstReader == current) {
	    firstReaderHoldCount++;
	} else {
	    HoldCounter rh = cachedHoldCounter;
	    if (rh == null || rh.tid != getThreadId(current))
		cachedHoldCounter = rh = readHolds.get();
	    else if (rh.count == 0)
		readHolds.set(rh);
	    rh.count++;
	}
	return 1;
    }
    return fullTryAcquireShared(current);
 }
