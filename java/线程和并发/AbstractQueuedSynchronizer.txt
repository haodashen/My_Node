官方文档说明：
	为实现依赖于先进先出（FIFO）的等待队列的阻塞锁和同步锁，提供了一个框架，该类被设计为大多数依赖单个原子int值来表示状态的同步器的一个有用的基础。
     子类必须定义一个受保护的方法，用于改变该状态值，并且定义哪种状态表示对象的获取和释放。考虑这些后，在该类中的其他方法可以实现队列和阻塞机制。子类
     可以包含其他的状态字段，但是必须使用getState()，setState(int)和compareAndSetState(int ,int)方法原子性的更新int值。

        子类必须定义一个非公共的内部帮助类，用于实现封闭类的同步属性，该类并没有实现任何同步接口，而是定义了一些方法，如：acquireInterruptibly(int)方法，
     在适当的时候可以通过具体的锁和相关的同步器来调用它们，以实现其公共方法。

        该及支持独占模式，也支持共享模式。如果是独占模式，则其他线程获取锁一定会失败，如果是共享模式，则其他线程可能会成功获取锁（但不一定）。类并不理解
     这之间的差异，处理机器的意识到当在共享模式下成功获取某一个锁时，下一个等待线程也必须确定是否可以成功获取该锁。在不同模式下的等待线程，可以共享
     FIFO队列，通常，子类的是实现仅支持一种模式，但是两者可以发挥作用，如ReadWriteLock类。仅支持独占模式或共享模式的子类并不需要实现自己不支持模式的
     方法。
        该类提供了一个实现了Condition接口的ConditionObject类

        该类为内部队列提供了检查，检测和监控的方法，同样也挺condition对象提供了相似的方法。可以使用该类的同步机制，将这些方法导出到自己希望的类中。
     该类的序列化操作仅存储了用于维护状态的基础原子整数值，因此反序列化对象有一个空的线程队列。需要序列化的典型子类定义一个readObject方法，该方法在
     反序列化时将该对象恢复到一个已知的初始状态。

AbstractQueuedSynchronizer内部实现的队列，队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点：
Node详解：
   private Node addWaiter(Node mode)
   {
        Node node = new Node(Thread.currentThread(), mode);
        // 快速尝试在尾部添加
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
	    //使用CAS确保节点能够被线程安全的添加
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }

    private Node enq(final Node node)
    {
        //使用死循环来确保节点的正确添加
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
     
    
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
