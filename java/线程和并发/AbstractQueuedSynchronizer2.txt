
设计一个同步工具：该工具在同一时刻，只允许有两个线程同时访问，超过两个线程就要堵塞。
由于可以多个线程访问，这显然是共享访问，因此，我们需要使用同步器的acquireShared(int arg)方法等和Shared相关方法，所以
我们需要重写tryAcquireShared和tryReleaseShared方法。

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
 * 
 *同一时刻，只允许有两个线程同时访问
 */
public class TwinsLock implements Lock
{
	private Sync sync = new Sync(2) ;
	
	private static final class Sync extends AbstractQueuedSynchronizer
	{
		public Sync(int count)
		{
			if(count <= 0 )
			{
				throw new IllegalArgumentException("count must large than zero");
			}
			setState(count);
		}
		
		@Override
		protected int tryAcquireShared(int arg) 
		{
			for(;;)
			{
				int current = getState();
				int newCount = current - arg; 
				if(newCount < 0 || compareAndSetState(current, newCount))
				{
					return newCount ;
				}
			}
		}
		
		@Override
		protected boolean tryReleaseShared(int arg)
		{
			for(;;)
			{
				int current = getState();
				int newCount = current+arg ;
				if(compareAndSetState(current, newCount))
				{
					return true ;
				}
			}
		}
	}
	@Override
	public void lock() {
		sync.acquireShared(1);
	}

	@Override
	public void lockInterruptibly() throws InterruptedException {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean tryLock() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void unlock() {
		sync.releaseShared(1);
	}

	@Override
	public Condition newCondition() {
		// TODO Auto-generated method stub
		return null;
	}
	
}

测试：
package code.lsh.thread;

import java.util.concurrent.locks.Lock;

public class TwinsLockTest
{
	private static Lock lock = new TwinsLock() ;
	
	static class Worker extends Thread
	{
		@Override
		public void run()
		{
			while(true)
			{
				lock.lock();
				try
				{
					try {
						Thread.sleep(1000);
						System.out.println(Thread.currentThread().getName());
						Thread.sleep(1000);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				finally
				{
					lock.unlock();
					System.out.println("----------------");
				}
			}
		}
	}
	public static void main(String[] args) 
	{
		for(int i = 0 ;i<10 ;i++)
		{
			Worker w = new Worker();
			w.start();
		}
	}
}

运行结果我们可以发现每次运行只有两个线程能获取锁。