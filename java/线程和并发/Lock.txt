原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。

CAS（Compare And Swap）：CAS(V,E,N)：V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说
                                             明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。CAS操作是抱着乐观的态度进行的，它总是任
											 为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出并成功更新，其余均会失败。失败的线程不会被
											 挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，基于这个原理，CAS操作仅使没有锁，也可以发现其他
											 线程对当前线程的干扰，并进行恰当的处理。
											  

可见性：一个线程对主内存的修改可以及时的被其他线程观察到
			volatile
				通过加入内存屏障和禁止重排序优化来实现
					对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存
					对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量。
			使用场景：1.对变量的写操作不依赖当前值
				              2.该变量不包括在其他变量中的不必的？中
有序性：java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
	happens-before原则：1.程序的次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写后面的操作。
									  2.锁定规则：一个unLock操纵先行发生于后面对同一个锁的lock操作。
									  3.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
									  4.传递规则：如果操作A先行与发生于操作B，而操作B有优先发生于操作C，则可以得出操作A先行发生于操作C。
									  5.线程启动规则：Thread对象的start()方法先行发生于次线程的每一个动作
									  6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
									  7.线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回
									                              值手段检测到线程已经终止执行。
									  8.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。
									  
发布对象：使一个对象能够被当前范围之外的代码所使用。
	安全发布对象方法：1.在静态初始化函数中初始化一个对象引用
									2.将对象的引用保存到volatile类型域或者AtomicReference对象中
									3.将对象的引用保存到某个正确构造对象的final类型域中
									4.将对象的引用保存到一个由锁保护的域中

对象溢出：一种错误的发布。当一个对象还没有构造完成时，就使它被其他线程所见。
	
	
guava
joda-time:
	https://docs.oracle.com/javase/8/
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	