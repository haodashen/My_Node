ReentrantLock:
  API说明；

 源码详解：
 ReentrantLock：分为公平锁和非公平锁。ReentrantLock源码中定义了一个抽象的，静态的内部类Sync（是同步监控的基础，子类实现了公平锁和非公平锁，使用
                AQS状态代表持有锁的个数），该类继承与AbstractQueuedSynchronizer。
     
     //无参构造方法，用于创建非公平锁
     public ReentrantLock()
     {
        sync = new NonfairSync();
     }

    //根据传入的fair来创建公平锁，还是非公平锁
    public ReentrantLock(boolean fair)
    {
        sync = fair ? new FairSync() : new NonfairSync();
    }

NonfairSync的lock方法:
    final void lock()
    {
         if (compareAndSetState(0, 1))
              setExclusiveOwnerThread(Thread.currentThread());
         else
            acquire(1);
    }
     //该方法属于AbsractQueuedSynchronizer，而子类实现了tryAcquire方法，独占式获取锁
     public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    该方法主要完成了同步状态的获取，节点的构造，加入同步队列以及同步队列中自旋等待的相关工作。

    





    //NonfairSync实现的tryAcquire方法，获取同步状态
    protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
    }
    //Sync实现了非公平获取锁方法
    final boolean nonfairTryAcquire(int acquires)
    {
        //获取当前线程
        final Thread current = Thread.currentThread();
	//获取状态值
        int c = getState();
	//如果状态值为0，表示锁还没有被占用
        if (c == 0) {
           if (compareAndSetState(0, acquires)) {
               setExclusiveOwnerThread(current);
               return true;
               }
            }
	    //判断是否为重入锁，即当前线程与占用锁的线程是否为同一个线程
            else if (current == getExclusiveOwnerThread()) {
	        //使同步状态值加1
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
		//更新同步状态值
                setState(nextc);
                return true;
            }
            return false;
     }




      //锁的释放
      protected final boolean tryRelease(int releases) 
      {
            //使同步状态值减一
            int c = getState() - releases;
	    //判断当前线程是否与占用锁的线程为同一个线程
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
	    //如果同步状态值为0，则表示锁被释放
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
      }




//公平的获取锁
protected final boolean tryAcquire(int acquires) 
{
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
	if (!hasQueuedPredecessors() &&
	    compareAndSetState(0, acquires)) {
	    setExclusiveOwnerThread(current);
	    return true;
	}
    }
    else if (current == getExclusiveOwnerThread()) {
	int nextc = c + acquires;
	if (nextc < 0)
	    throw new Error("Maximum lock count exceeded");
	setState(nextc);
	return true;
    }
    return false;
}
从代码中，我们可以看出与nonfairTryAcquire方法比较，唯一的不同的位置为判断条件多了hasQueuedPredecessors方法的，即加入
了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取
并释放锁之后才能继续获取锁。


































