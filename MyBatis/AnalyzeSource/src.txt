
1.InputStream input = Resources.getResourceAsStream("mybatis-config.xml");
2.SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(input);
3.SqlSession sqlSession = factory.openSession();

 public static InputStream getResourceAsStream(String resource) throws IOException {
    return getResourceAsStream(null, resource);
}
该方法会到classpath路径下加载我们指定的文件
public static InputStream getResourceAsStream(ClassLoader loader, String resource) throws IOException {
    InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader);
    if (in == null) {
      throw new IOException("Could not find resource " + resource);
    }
    return in;
}
//这里使用Builder模式来初始化SqlSessionFactory类
 public SqlSessionFactory build(InputStream inputStream) {
    return build(inputStream, null, null);
 }
 
   XmlConfigBuilder是用来解析MyBatis核心配置文件。
  public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) {
	//这里创建了XPathParse对象
    this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);
  }
   
   public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
    try {
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      return build(parser.parse());
    } catch (Exception e) {
    } finally {
      ErrorContext.instance().reset();
      try {
	    //无论程序是否能够正常指向，最后都会关闭输入流
        inputStream.close();
      } catch (IOException e) {
      }
    }
  }
  parser.parse()方法：
  public Configuration parse() {
    if (parsed) {
      throw new BuilderException("Each XMLConfigBuilder can only be used once.");
    }
    parsed = true;
	//parser.evalNode方法将整个配置文件内容，封装到XNode中
    parseConfiguration(parser.evalNode("/configuration"));
    return configuration;
  }
  
  private void parseConfiguration(XNode root) {
    try {
      //解析properties标签
      propertiesElement(root.evalNode("properties"));
	  //解析settings标签
      Properties settings = settingsAsProperties(root.evalNode("settings"));
      loadCustomVfs(settings);
	  //解析typeAliases标签
      typeAliasesElement(root.evalNode("typeAliases"));
	  //解析plugins标签
      pluginElement(root.evalNode("plugins"));
      objectFactoryElement(root.evalNode("objectFactory"));
      objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
      reflectorFactoryElement(root.evalNode("reflectorFactory"));
      settingsElement(settings);
      //解析environments标签
      environmentsElement(root.evalNode("environments"));
      databaseIdProviderElement(root.evalNode("databaseIdProvider"));
      typeHandlerElement(root.evalNode("typeHandlers"));
	  //解析mappers标签，这里是核心
      mapperElement(root.evalNode("mappers"));
    } catch (Exception e) {
      throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
    }
  }

解析mybatis核心配置文件中的mappers标签
private void mapperElement(XNode parent) throws Exception {
if (parent != null) {
  for (XNode child : parent.getChildren()) {
	//首先解析<mapper package="">型的标签，说明package优先级高。
	if ("package".equals(child.getName())) {
	  String mapperPackage = child.getStringAttribute("name");
	  configuration.addMappers(mapperPackage);
	} else {
	  String resource = child.getStringAttribute("resource");
	  String url = child.getStringAttribute("url");
	  String mapperClass = child.getStringAttribute("class");
	  if (resource != null && url == null && mapperClass == null) {
		ErrorContext.instance().resource(resource);
		//获取Mapper文件的输入流
		InputStream inputStream = Resources.getResourceAsStream(resource);
		XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
		mapperParser.parse();
	  } else if (resource == null && url != null && mapperClass == null) {
		ErrorContext.instance().resource(url);
		InputStream inputStream = Resources.getUrlAsStream(url);
		XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
		mapperParser.parse();
	  } else if (resource == null && url == null && mapperClass != null) {
		Class<?> mapperInterface = Resources.classForName(mapperClass);
		configuration.addMapper(mapperInterface);
	  } else {
		throw new BuilderException("A mapper element may only specify a url, resource or class, but not more than one.");
	  }
	}
  }
}
}
加载Mapper文件有四种：<mapper package="" /> <mapper resource=""/> <mapper url="""/> <mapper class=""/>
从源码中我们可以发现，我们的Mapper文件是由类：XMLMapperBuilder进行解析的。
XMLMapperBuilder：构造方法
 public XMLMapperBuilder(InputStream inputStream, Configuration configuration, String resource, Map<String, XNode> sqlFragments) {
    //生成XPathParser对象
    this(new XPathParser(inputStream, true, configuration.getVariables(), new XMLMapperEntityResolver()),
        configuration, resource, sqlFragments);
  }
 private XMLMapperBuilder(XPathParser parser, Configuration configuration, String resource, Map<String, XNode> sqlFragments) {
    super(configuration);
    this.builderAssistant = new MapperBuilderAssistant(configuration, resource);
    this.parser = parser;
    this.sqlFragments = sqlFragments;
    this.resource = resource;//这里将我们传递的resource赋值了成员变量
  }
  
XMLMapperBuilder.parse()方法：
public void parse() {
    //首先判断resouce是否已经被加载过了
	if (!configuration.isResourceLoaded(resource)) {
	  //parser.evalNode方法将我们定义的Mapper文件封装成XNode对象
	  configurationElement(parser.evalNode("/mapper"));
	  configuration.addLoadedResource(resource);
	  bindMapperForNamespace();
	}
	parsePendingResultMaps();
	parsePendingChacheRefs();
	parsePendingStatements();
}
configurationElement方法：
private void configurationElement(XNode context) {
    try {
      String namespace = context.getStringAttribute("namespace");
      if (namespace == null || namespace.equals("")) {
        throw new BuilderException("Mapper's namespace cannot be empty");
      }
      builderAssistant.setCurrentNamespace(namespace);
      cacheRefElement(context.evalNode("cache-ref"));
      cacheElement(context.evalNode("cache"));
      parameterMapElement(context.evalNodes("/mapper/parameterMap"));
      resultMapElements(context.evalNodes("/mapper/resultMap"));
      sqlElement(context.evalNodes("/mapper/sql"));
	  //解析我们写的SQL语句
      buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
    } catch (Exception e) {
      throw new BuilderException("Error parsing Mapper XML. Cause: " + e, e);
    }
  }

  private void buildStatementFromContext(List<XNode> list) {
    //判断数据库
    if (configuration.getDatabaseId() != null) {
      buildStatementFromContext(list, configuration.getDatabaseId());
    }
    buildStatementFromContext(list, null);
  }
  
private void buildStatementFromContext(List<XNode> list, String requiredDatabaseId) {
    //循环解析我们的SQL语句
	for (XNode context : list) {
	  final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
	  try {
		statementParser.parseStatementNode();
	  } catch (IncompleteElementException e) {
		configuration.addIncompleteStatement(statementParser);
	  }
	}
}
XMLStatementBuilder类主要用于
  public XMLStatementBuilder(Configuration configuration, MapperBuilderAssistant builderAssistant, XNode context, String databaseId) {
    super(configuration);
    this.builderAssistant = builderAssistant;
    this.context = context;
    this.requiredDatabaseId = databaseId;
  }
  
parseStatementNode方法：
 public void parseStatementNode() {
    //首先获取id
    String id = context.getStringAttribute("id");
    String databaseId = context.getStringAttribute("databaseId");
    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {
      return;
    }
    Integer fetchSize = context.getIntAttribute("fetchSize");
    Integer timeout = context.getIntAttribute("timeout");
    String parameterMap = context.getStringAttribute("parameterMap");
    String parameterType = context.getStringAttribute("parameterType");
    Class<?> parameterTypeClass = resolveClass(parameterType);
    String resultMap = context.getStringAttribute("resultMap");
    String resultType = context.getStringAttribute("resultType");
    String lang = context.getStringAttribute("lang");
    LanguageDriver langDriver = getLanguageDriver(lang);
    //生成结果类型实例
    Class<?> resultTypeClass = resolveClass(resultType);
    String resultSetType = context.getStringAttribute("resultSetType");
    StatementType statementType = StatementType.valueOf(context.getStringAttribute("statementType", StatementType.PREPARED.toString()));
    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);
    //获取节点名称
    String nodeName = context.getNode().getNodeName();
    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));
    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;
    boolean flushCache = context.getBooleanAttribute("flushCache", !isSelect);
    boolean useCache = context.getBooleanAttribute("useCache", isSelect);
    boolean resultOrdered = context.getBooleanAttribute("resultOrdered", false);

    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);
    includeParser.applyIncludes(context.getNode());
	
    processSelectKeyNodes(id, parameterTypeClass, langDriver);
    
    // 解析(pre: <selectKey> and <include> were parsed and removed)
    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);
    String resultSets = context.getStringAttribute("resultSets");
    String keyProperty = context.getStringAttribute("keyProperty");
    String keyColumn = context.getStringAttribute("keyColumn");
    KeyGenerator keyGenerator;
    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;
    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);
    if (configuration.hasKeyGenerator(keyStatementId)) {
      keyGenerator = configuration.getKeyGenerator(keyStatementId);
    } else {
      keyGenerator = context.getBooleanAttribute("useGeneratedKeys",
          configuration.isUseGeneratedKeys() && SqlCommandType.INSERT.equals(sqlCommandType))
          ? new Jdbc3KeyGenerator() : new NoKeyGenerator();
    }

    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,
        resultSetTypeEnum, flushCache, useCache, resultOrdered, 
        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);
  }





 public MappedStatement addMappedStatement(
      String id,
      SqlSource sqlSource,
      StatementType statementType,
      SqlCommandType sqlCommandType,
      Integer fetchSize,
      Integer timeout,
      String parameterMap,
      Class<?> parameterType,
      String resultMap,
      Class<?> resultType,
      ResultSetType resultSetType,
      boolean flushCache,
      boolean useCache,
      boolean resultOrdered,
      KeyGenerator keyGenerator,
      String keyProperty,
      String keyColumn,
      String databaseId,
      LanguageDriver lang,
      String resultSets) {

    if (unresolvedCacheRef) {
      throw new IncompleteElementException("Cache-ref not yet resolved");
    }

    id = applyCurrentNamespace(id, false);
    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;

    MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)
        .resource(resource)
        .fetchSize(fetchSize)
        .timeout(timeout)
        .statementType(statementType)
        .keyGenerator(keyGenerator)
        .keyProperty(keyProperty)
        .keyColumn(keyColumn)
        .databaseId(databaseId)
        .lang(lang)
        .resultOrdered(resultOrdered)
        .resultSets(resultSets)
        .resultMaps(getStatementResultMaps(resultMap, resultType, id))
        .resultSetType(resultSetType)
        .flushCacheRequired(valueOrDefault(flushCache, !isSelect))
        .useCache(valueOrDefault(useCache, isSelect))
        .cache(currentCache);

    ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);
    if (statementParameterMap != null) {
      statementBuilder.parameterMap(statementParameterMap);
    }
    //这里将SQL语句解析为MappedStatement对象
    MappedStatement statement = statementBuilder.build();
    configuration.addMappedStatement(statement);
    return statement;
  }
DefaultSqlSession是线程不安全类。


select 部门id，部门名，count(员工id) as 部门人数  from 部门表 ,员工表 where 部门表.部门id=员工表.部门表









